parent_classes:


  - class: AllegroFlare::CSVParser
    scope: public
    init_with: ''


properties:


  - name: assets_bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: csv_full_path
    type: std::string
    init_with: '"[unset-csv_full_path]"'
    getter: true
    setter: true

  - name: levels
    type: std::map<std::string, AssetStudio::Asset*>
    init_with: '{}'
    getter: explicit

  - name: loaded
    type: bool
    init_with: false
    

methods:


  - name: get_levels
    type: std::map<std::string, AssetStudio::Asset*>
    guards: [ loaded ]
    body: |
      return levels;


  - name: level_exists
    type: bool
    parameters:
      - name: level_identifier
        type: std::string
        default_argument: '"[unset-level_identifier]"'
    guards: [ loaded ]
    body: |
      return (levels.find(level_identifier) != levels.end());


  - name: toi
    type: int
    static: true
    parameters:
      - name: value
        type: std::string
        default_argument: '"[unset-value]"'
    body: |
      if (value.empty()) return 0;
      if (value[0] == '+') value.erase(0, 1); // Pop front on the '+' sign
      return std::atoi(value.c_str());
    body_dependency_symbols:
      - std::atoi


  - name: tof
    type: float
    static: true
    parameters:
      - name: value
        type: std::string
        default_argument: '"[unset-value]"'
    body: |
      if (value.empty()) return 0;
      if (value[0] == '+') value.erase(0, 1); // Pop front on the '+' sign
      return std::stof(value.c_str());
    body_dependency_symbols:
      - std::stof


  - name: str_to_playmode
    type: std::pair<bool, uint32_t>
    parameters:
      - name: playmode_string
        type: std::string
        default_argument: '"[unset-playmode_string]"'
    body: |
      if (playmode_string == "once")
      {
         return { true, AllegroFlare::FrameAnimation::Animation::PLAYMODE_FORWARD_ONCE };
      }
      else if (playmode_string == "loop")
      {
         return { true, AllegroFlare::FrameAnimation::Animation::PLAYMODE_FORWARD_LOOP };
      }
      else if (playmode_string == "ping_pong_forward")
      {
         return { true, AllegroFlare::FrameAnimation::Animation::PLAYMODE_FORWARD_PING_PONG };
      }

      return { false, 0 };


  - name: find_level
    xtype: Robieo::Gameplay::Level
    type: AssetStudio::Asset*
    parameters:
      - name: level_identifier
        type: std::string
        default_argument: '"[unset-level_identifier]"'
    guards: [ loaded, level_exists(level_identifier) ]
    body: |
      return levels[level_identifier];


  - name: validate_key_and_return
    type: std::string
    static: true
    parameters:
      - name: extracted_row
        type: std::map<std::string, std::string>*
        default_argument: nullptr
      - name: key
        type: std::string
        default_argument: '"[unset-key]"'
    body: |
      if (extracted_row->count(key) == 0)
      {
         std::vector<std::string> valid_keys;
         for (const auto& pair : *extracted_row) valid_keys.push_back(pair.first);

         std::stringstream ss;
         ss << "[";
         for (auto &valid_key : valid_keys)
         {
            ss << "\"" << valid_key << "\", ";
         }
         ss << "]";

         AllegroFlare::Logger::throw_error(
            "Robieo::CSVToLevelLoader::validate_key_and_return",
            "key \"" + key + "\" does not exist. The following keys are present: " + ss.str() + "."
         );
      }
      return extracted_row->operator[](key);
    body_dependency_symbols:
      - AllegroFlare::Logger


  - name: obtain_sprite_sheet
    type: AllegroFlare::FrameAnimation::SpriteSheet*
    private: true
    parameters:
      - name: filename
        type: std::string
        default_argument: '"[unset-filename]"'
      - name: cell_width
        type: int
        default_argument: 16
      - name: cell_height
        type: int
        default_argument: 16
      - name: sprite_sheet_scale
        type: int
        default_argument: 2
    guards: [ assets_bitmap_bin ]
    body: |
      // TODO: Guard after assets_bitmap_bin is initialized

      ALLEGRO_BITMAP* sprite_sheet_atlas = al_clone_bitmap(
            assets_bitmap_bin->auto_get(filename)
            //assets_bitmap_bin.auto_get("grotto_escape_pack/Base pack/graphics/player.png")
         );
      AllegroFlare::FrameAnimation::SpriteSheet *result_sprite_sheet =
         new AllegroFlare::FrameAnimation::SpriteSheet(sprite_sheet_atlas, cell_width, cell_height, sprite_sheet_scale);

      al_destroy_bitmap(sprite_sheet_atlas);

      return result_sprite_sheet;
    body_dependency_symbols:
      - AllegroFlare::FrameAnimation::SpriteSheet


  - name: build_n_frames
    type: std::vector<AllegroFlare::FrameAnimation::Frame>
    parameters:
      - name: num_frames
        type: uint32_t
        default_argument: 1
      - name: start_frame_num
        type: uint32_t
        default_argument: 0
      - name: each_frame_duration
        type: float
        default_argument: 0.08f
    guards: [ (num_frames > 1), (start_frame_num >= 0), (each_frame_duration >= 0.0001) ]
    body: |
      std::vector<AllegroFlare::FrameAnimation::Frame> result;
      for (uint32_t i=0; i<num_frames; i++)
      {
         result.push_back({ start_frame_num + i, each_frame_duration });
      }
      return result;


  - name: build_frames_from_hash
    type: std::vector<AllegroFlare::FrameAnimation::Frame>
    parameters:
      - name: frame_data_hash
        type: std::string
        default_argument: '"[unset-frame_data_hash]"'
    body: |
      AllegroFlare::Logger::throw_error(
         "AssetStudio::DatabaseCSVLoader::build_frames_from_hash",
         "This feature is not yet supported."
      );

      std::vector<AllegroFlare::FrameAnimation::Frame> result;
      return result;


  - name: load
    guards: [ (!loaded), assets_bitmap_bin ]
    body: |
      // Obtain the content from the file and parse it to extractable data
      std::string content = AllegroFlare::php::file_get_contents(csv_full_path);
      if (content.empty()) throw std::runtime_error("empty file content");
      AllegroFlare::CSVParser csv_parser;
      csv_parser.set_raw_csv_content(content);
      csv_parser.parse();
      csv_parser.assemble_column_headers(3);

      // Load the parsed data to Level objects
      int first_physical_row = csv_parser.get_num_header_rows();
      int row_i = first_physical_row;
      for (std::map<std::string, std::string> &extracted_row : csv_parser.extract_all_rows())
      {
         // Extract the data here
         std::string identifier = validate_key_and_return(&extracted_row, "identifier");
         int id = toi(validate_key_and_return(&extracted_row, "id"));
         int cell_width = toi(validate_key_and_return(&extracted_row, "cell_width"));
         int cell_height = toi(validate_key_and_return(&extracted_row, "cell_height"));
         std::string image_filename = validate_key_and_return(&extracted_row, "image_filename");
         std::string playmode = validate_key_and_return(&extracted_row, "playmode");

         std::string frame_data__in_hash = validate_key_and_return(&extracted_row, "frame_data__in_hash");
         std::string frame_data__build_n_frames__num_frames =
            validate_key_and_return(&extracted_row, "frame_data__build_n_frames__num_frames");
         std::string frame_data__build_n_frames__start_from_frame =
            validate_key_and_return(&extracted_row, "frame_data__build_n_frames__start_from_frame");
         std::string frame_data__build_n_frames__each_frame_duration =
            validate_key_and_return(&extracted_row, "frame_data__build_n_frames__each_frame_duration");

         bool using_build_n_frames_frame_data = 
            !(
                  frame_data__build_n_frames__num_frames.empty()
               && frame_data__build_n_frames__start_from_frame.empty()
               && frame_data__build_n_frames__each_frame_duration.empty()
            );
         bool using_in_hash_frame_data = !frame_data__in_hash.empty();

         std::vector<AllegroFlare::FrameAnimation::Frame> frame_data;

         if (using_build_n_frames_frame_data && using_in_hash_frame_data)
         {
            AllegroFlare::Logger::throw_error(
               "AssetStudio::DatabaseCSVLoader::load",
               "When loading row " + std::to_string(row_i) + ", both \"build_n_frames\" and \"in_hash\" sections "
                  "contain data. Either one section or the other should be used, but not both."
            );
         }
         else if (!using_build_n_frames_frame_data && !using_in_hash_frame_data)
         {
            // NOTE: Assuming this is a tileset
            // TODO: Consider outputting an "info", "warning", or maybe guarding with a type==tileset or something.
            //AllegroFlare::Logger::throw_error(
               //"AssetStudio::DatabaseCSVLoader::load",
               //"When loading row " + std::to_string(row_i) + ", both \"build_n_frames\" and \"in_hash\" sections are "
                  //"empty. Expecting some data there."
            //);
         }
         else if (using_build_n_frames_frame_data)
         {
            frame_data = build_n_frames(
                  toi(frame_data__build_n_frames__num_frames), // TODO: Test this int
                  toi(frame_data__build_n_frames__start_from_frame), // TODO: Test this int
                  tof(frame_data__build_n_frames__each_frame_duration) // TODO: Test this float
               );
         }
         else if (using_in_hash_frame_data)
         {
            frame_data = build_frames_from_hash(frame_data__in_hash);
         }
         else
         {
            AllegroFlare::Logger::throw_error(
               "AssetStudio::DatabaseCSVLoader::load",
               "Weird error 2324jfgasodjifas."
            );
         }

         std::pair<bool, uint32_t> playmode_parsed_data =
               { true, AllegroFlare::FrameAnimation::Animation::PLAYMODE_FORWARD_ONCE };

         if (!playmode.empty())
         {
            std::pair<bool, uint32_t> playmode_parsed_data = str_to_playmode(playmode);
         }

         if (playmode_parsed_data.first == false)
         {
            AllegroFlare::Logger::throw_error(
               "AssetStudio::DatabaseCSVLoader::load",
               "Unrecognized playmode \"" + playmode + "\" when loading row " + std::to_string(row_i) + "."
            );
         }

         // Build the animation
         AllegroFlare::FrameAnimation::Animation *animation =
            new AllegroFlare::FrameAnimation::Animation(
               obtain_sprite_sheet(image_filename, cell_width, cell_height, 2),
               identifier,
               frame_data,
               playmode_parsed_data.second
            );

         // Load the data into the asset
         AssetStudio::Asset *asset = new AssetStudio::Asset;
         asset->id = id;
         asset->identifier = identifier;
         asset->animation = animation;
         asset->cell_width = cell_width;
         asset->cell_height = cell_height;

         //asset->cell_width = cell_width;
         //asset->cell_height = cell_height;
         // Build up the animation
         //asset->name = image_filename;
         //asset->description = description;

         levels.insert({ identifier, asset });
         
         /*
         // Pull out the variables
         std::string identifier =
            validate_key_and_return(&extracted_row, "identifier");
         std::string title =
            validate_key_and_return(&extracted_row, "title");
         std::string world_model_obj_filename =
            validate_key_and_return(&extracted_row, "world__model_obj_filename");
         std::string world_model_texture_filename =
            validate_key_and_return(&extracted_row, "world__model_texture_filename");
         std::string environment_model_obj_filename =
            validate_key_and_return(&extracted_row, "environment__model_obj_filename");
         std::string environment_model_texture_filename =
            validate_key_and_return(&extracted_row, "environment__model_texture_filename");

         std::string background_music_identifier =
            validate_key_and_return(&extracted_row, "background_music_identifier");
         std::string song_to_perform_identifier =
            validate_key_and_return(&extracted_row, "song_to_perform__identifier");
         float song_to_perform_duration_sec =
            tof(validate_key_and_return(&extracted_row, "song_to_perform__duration_sec"));

         float primary_light_spin =
            tof(validate_key_and_return(&extracted_row, "primary_light__spin"));
         float primary_light_tilt_time_of_day =
            tof(validate_key_and_return(&extracted_row, "primary_light__tilt_time_of_day"));



         // Pass along the variables to the result object
         Robieo::Gameplay::Level level;
         level.set_title(title);

         level.set_world_model_obj_filename(world_model_obj_filename);
         level.set_world_model_texture_filename(world_model_texture_filename);


         if (!environment_model_obj_filename.empty())
         {
            AllegroFlare::Logger::info_from(
               "Robieo::CSVToLevelLoader::load",
               "environment obj model for level detected: \"" + environment_model_obj_filename + "\""
            );
            level.set_environment_model_obj_filename(environment_model_obj_filename);
            level.set_environment_model_texture_filename(environment_model_texture_filename);
         }



         {
         level.get_tile_maps_ref().push_back({});
         auto &tile_map = level.get_tile_maps_ref().back();

         std::string tile_map_tile_elevation_bitmap_filename =
            validate_key_and_return(&extracted_row, "tile_map_ground_floor__tile_elevation_bitmap_filename");
         std::string tile_map_tile_type_bitmap_filename =
            validate_key_and_return(&extracted_row, "tile_map_ground_floor__tile_type_bitmap_filename");
         //std::cout << "tile_map_tile_elevation_bitmap_filename: " << tile_map_tile_elevation_bitmap_filename << std::endl;
         //std::cout << "tile_map_tile_type_bitmap_filename: " << tile_map_tile_type_bitmap_filename << std::endl;

         int tile_map_origin_offset_x = toi(validate_key_and_return(&extracted_row, "tile_map_ground_floor__origin_offset__x"));
         int tile_map_origin_offset_y = toi(validate_key_and_return(&extracted_row, "tile_map_ground_floor__origin_offset__y"));
         float tile_map_ceiling_height = tof(validate_key_and_return(&extracted_row, "tile_map_ground_floor__ceiling_height"));
         float tile_map_groundlevel_height = tof(validate_key_and_return(&extracted_row, "tile_map_ground_floor__groundlevel_height"));
         float tile_map_floor_height = tof(validate_key_and_return(&extracted_row, "tile_map_ground_floor__floor_height"));

         tile_map.set_tile_elevation_bitmap_filename(tile_map_tile_elevation_bitmap_filename);
         tile_map.set_tile_type_bitmap_filename(tile_map_tile_type_bitmap_filename);
         tile_map.set_origin_offset({ (float)tile_map_origin_offset_x, (float)tile_map_origin_offset_y });
         tile_map.set_ceiling_height(tile_map_ceiling_height);
         tile_map.set_groundlevel_height(tile_map_groundlevel_height);
         tile_map.set_floor_height(tile_map_floor_height);
         }





         {
           //int num = 1;
         //level.get_tile_maps_ref().push_back({});
         //auto &tile_map = level.get_tile_maps_ref()[0];

         std::string tile_map_tile_elevation_bitmap_filename =
            validate_key_and_return(&extracted_row, "tile_map_floor2__tile_elevation_bitmap_filename");
         std::string tile_map_tile_type_bitmap_filename =
            validate_key_and_return(&extracted_row, "tile_map_floor2__tile_type_bitmap_filename");

         //std::cout << "tile_map_tile_elevation_bitmap_filename: " << tile_map_tile_elevation_bitmap_filename << std::endl;
         //std::cout << "tile_map_tile_type_bitmap_filename: " << tile_map_tile_type_bitmap_filename << std::endl;

            // TODO: Better validation
            if (!tile_map_tile_elevation_bitmap_filename.empty())
            {

            level.get_tile_maps_ref().push_back({});
            auto &tile_map = level.get_tile_maps_ref().back();
            int tile_map_origin_offset_x = toi(validate_key_and_return(&extracted_row, "tile_map_floor2__origin_offset__x"));
            int tile_map_origin_offset_y = toi(validate_key_and_return(&extracted_row, "tile_map_floor2__origin_offset__y"));
            float tile_map_ceiling_height = tof(validate_key_and_return(&extracted_row, "tile_map_floor2__ceiling_height"));
            float tile_map_groundlevel_height = tof(validate_key_and_return(&extracted_row, "tile_map_floor2__groundlevel_height"));
            float tile_map_floor_height = tof(validate_key_and_return(&extracted_row, "tile_map_floor2__floor_height"));

            tile_map.set_tile_elevation_bitmap_filename(tile_map_tile_elevation_bitmap_filename);
            tile_map.set_tile_type_bitmap_filename(tile_map_tile_type_bitmap_filename);
            tile_map.set_origin_offset({ (float)tile_map_origin_offset_x, (float)tile_map_origin_offset_y });
            tile_map.set_ceiling_height(tile_map_ceiling_height);
            tile_map.set_groundlevel_height(tile_map_groundlevel_height);
            tile_map.set_floor_height(tile_map_floor_height);
            }
         }




         {
           //int num = 1;
         //level.get_tile_maps_ref().push_back({});
         //auto &tile_map = level.get_tile_maps_ref()[0];

         std::string tile_map_tile_elevation_bitmap_filename =
            validate_key_and_return(&extracted_row, "tile_map_basement1__tile_elevation_bitmap_filename");
         std::string tile_map_tile_type_bitmap_filename =
            validate_key_and_return(&extracted_row, "tile_map_basement1__tile_type_bitmap_filename");

         //std::cout << "tile_map_tile_elevation_bitmap_filename: " << tile_map_tile_elevation_bitmap_filename << std::endl;
         //std::cout << "tile_map_tile_type_bitmap_filename: " << tile_map_tile_type_bitmap_filename << std::endl;

            // TODO: Better validation
            if (!tile_map_tile_elevation_bitmap_filename.empty())
            {

            level.get_tile_maps_ref().push_back({});
            auto &tile_map = level.get_tile_maps_ref().back();
            int tile_map_origin_offset_x = toi(validate_key_and_return(&extracted_row, "tile_map_basement1__origin_offset__x"));
            int tile_map_origin_offset_y = toi(validate_key_and_return(&extracted_row, "tile_map_basement1__origin_offset__y"));
            float tile_map_ceiling_height = tof(validate_key_and_return(&extracted_row, "tile_map_basement1__ceiling_height"));
            float tile_map_groundlevel_height = tof(validate_key_and_return(&extracted_row, "tile_map_basement1__groundlevel_height"));
            float tile_map_floor_height = tof(validate_key_and_return(&extracted_row, "tile_map_basement1__floor_height"));

            tile_map.set_tile_elevation_bitmap_filename(tile_map_tile_elevation_bitmap_filename);
            tile_map.set_tile_type_bitmap_filename(tile_map_tile_type_bitmap_filename);
            tile_map.set_origin_offset({ (float)tile_map_origin_offset_x, (float)tile_map_origin_offset_y });
            tile_map.set_ceiling_height(tile_map_ceiling_height);
            tile_map.set_groundlevel_height(tile_map_groundlevel_height);
            tile_map.set_floor_height(tile_map_floor_height);
            }
         }




         {
           //int num = 1;
         //level.get_tile_maps_ref().push_back({});
         //auto &tile_map = level.get_tile_maps_ref()[0];

         std::string tile_map_tile_elevation_bitmap_filename =
            validate_key_and_return(&extracted_row, "tile_map_basement2__tile_elevation_bitmap_filename");
         std::string tile_map_tile_type_bitmap_filename =
            validate_key_and_return(&extracted_row, "tile_map_basement2__tile_type_bitmap_filename");

         //std::cout << "tile_map_tile_elevation_bitmap_filename: " << tile_map_tile_elevation_bitmap_filename << std::endl;
         //std::cout << "tile_map_tile_type_bitmap_filename: " << tile_map_tile_type_bitmap_filename << std::endl;

            // TODO: Better validation
            if (!tile_map_tile_elevation_bitmap_filename.empty())
            {

            level.get_tile_maps_ref().push_back({});
            auto &tile_map = level.get_tile_maps_ref().back();
            int tile_map_origin_offset_x = toi(validate_key_and_return(&extracted_row, "tile_map_basement2__origin_offset__x"));
            int tile_map_origin_offset_y = toi(validate_key_and_return(&extracted_row, "tile_map_basement2__origin_offset__y"));
            float tile_map_ceiling_height = tof(validate_key_and_return(&extracted_row, "tile_map_basement2__ceiling_height"));
            float tile_map_groundlevel_height = tof(validate_key_and_return(&extracted_row, "tile_map_basement2__groundlevel_height"));
            float tile_map_floor_height = tof(validate_key_and_return(&extracted_row, "tile_map_basement2__floor_height"));

            tile_map.set_tile_elevation_bitmap_filename(tile_map_tile_elevation_bitmap_filename);
            tile_map.set_tile_type_bitmap_filename(tile_map_tile_type_bitmap_filename);
            tile_map.set_origin_offset({ (float)tile_map_origin_offset_x, (float)tile_map_origin_offset_y });
            tile_map.set_ceiling_height(tile_map_ceiling_height);
            tile_map.set_groundlevel_height(tile_map_groundlevel_height);
            tile_map.set_floor_height(tile_map_floor_height);
            }
         }





         //level.set_tile_elevation_bitmap_filename(tile_map_tile_elevation_bitmap_filename);
         //level.set_tile_map_tile_type_bitmap_filename(tile_map_tile_type_bitmap_filename);
         //level.set_tile_map_origin_offset({ (float)tile_map_origin_offset_x, (float)tile_map_origin_offset_y });
         //level.set_tile_map_ceiling_height(tile_map_ceiling_height);
         //level.set_tile_map_groundlevel_height(tile_map_groundlevel_height);
         //level.set_tile_map_floor_height(tile_map_floor_height);

         level.set_primary_light_spin(primary_light_spin);
         level.set_primary_light_tilt_time_of_day(primary_light_tilt_time_of_day);


         level.set_background_music_identifier(background_music_identifier);
         level.set_song_to_perform_identifier(song_to_perform_identifier);
         level.set_song_to_perform_duration_sec(song_to_perform_duration_sec);

         levels.insert({ identifier, level });

         */
         row_i++;
      }

      loaded = true;
      return;
    body_dependency_symbols:
      - AllegroFlare::CSVParser
      - AllegroFlare::UsefulPHP


dependencies:


  - symbol: AllegroFlare::CSVParser
    headers: [ AllegroFlare/CSVParser.hpp ]
  - symbol: AllegroFlare::UsefulPHP
    headers: [ AllegroFlare/UsefulPHP.hpp ]
  - symbol: SurviveTheCity::CSVParser
    headers: [ SurviveTheCity/CSVParser.hpp ]
  - symbol: AssetStudio::Asset
    headers: [ AssetStudio/Asset.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: std::atoi
    headers: [ cstdlib ]
  - symbol: std::stof
    headers: [ string ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::FrameAnimation::SpriteSheet
    headers: [ AllegroFlare/FrameAnimation/SpriteSheet.hpp ]
  - symbol: AllegroFlare::FrameAnimation::Frame
    headers: [ AllegroFlare/FrameAnimation/Frame.hpp ]


